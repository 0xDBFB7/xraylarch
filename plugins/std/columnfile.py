#!/usr/bin/env python
"""
  Larch column file reader: read_ascii)_
"""
import time
import numpy
from larch.utils import fixName
from larch.symboltable import isgroup

MODNAME = '_io'

def _read_ascii(fname, commentchars='#;%', labels=None, _larch=None):
    """read a column ascii column file.
    The commentchar argument (#;% by default) sets the valid comment characters:
    if the the first character in a line matches one of these, the line is marked
    as a  header lines.

    Header lines continue until a line with
       '#----' (any commentchar followed by 4 '-'
    The line immediately following that is read as column labels
    (space delimited)

    If the header is of the form
       # KEY : VAL   (ie commentchar key ':' value)
    these will be parsed into a 'attributes' dictionary
    in the returned group.

    If labels is left the default value of None, column labels will be used
    as the variable names. Variables from extra, unnamed columns will be
    called 'col1', 'col2'.

    If labels=False, the 'data' variable will contain the 2-dimensional data.
    """
    finp = open(fname, 'r')
    kws = {'filename': fname}
    _labels = None
    text = finp.readlines()
    finp.close()
    data = []
    header_txt = []
    header_kws = {}
    islabel = False
    for iline, line in enumerate(text):
        line = line[:-1].strip()
        if line[0] in commentchar:
            if islabel:
                _labels = line[1:].strip()
                islabel = False
            elif line[2:].strip().startswith('---'):
                islabel = True
            else:
                words = line[1:].split(':', 1)
                key = fixName(words[0].strip())
                if key.startswith('_'):
                    key = key[1:]
                if len(words) == 1:
                    header_txt.append(words[0].strip())
                else:
                    header_kws[key] = words[1].strip()
        else:
            words = line.split()
            data.append([float(w) for w in words])


    if len(header_txt) > 0:
        header_kws['header'] = '\n'.join(header_txt)
    kws['attributes'] = header_kws
    kws['column_labels'] = []
    if labels is None:
        labels = _labels
    if labels is None:
        labels = header_txt.pop()
    data = numpy.array(data).transpose()
    ncol, nrow = data.shape
    if not labels:
        kws['data'] = data
    else:
        try:
            labels = labels.replace(',', ' ').split()
        except:
            labels = []
        for icol in range(ncol):
            colname = 'col%i' % (1+icol)
            if icol < len(labels):
                colname = fixName(labels[icol].strip().lower())
            kws[colname] = data[icol]
            kws['column_labels'].append(colname)

    group = kws

    if _larch is not None:
        group = _larch.symtable.create_group(name='ascii_file %s' % fname)
        atgrp = _larch.symtable.create_group(
            name='header attributes from %s' % fname)
        for key, val in kws['attributes'].items():
            setattr(atgrp, key, val)

        kws['attributes'] = atgrp
        for key, val in kws.items():
            setattr(group, key, val)
    return group



def write_ascii(filename, *args, **kws):
    """
    write a list of items to an ASCII column file

    arguments
    ---------
       commentchar: character for comment ('#')
       label      : array label line (autogenerated)
       header     : array of strings for header
       
    """
    ARRAY_MINLEN = 5
    _larch = kws.get('_larch', None)
    if _larch is None:
        raise Warning("cannot calculate autobk spline -- larch broken?")
    com = kws.get('commentchar', '#')
    label = kws.get('label', None)
    header = kws.get('header', [])
    
    arrays = []
    arraylen = None

    for arg in args:
        if isinstance(arg, numpy.ndarray):
            if len(arg) > ARRAY_MINLEN:
                if arraylen is None:
                    arraylen = len(arg)
                else:
                    arraylen = min(arraylen, len(arg))
                arrays.append(arg)
            else:
                header.append(repr(arg))

        else:
            header.append(repr(arg))
   
    
    buff = ['%s Output from Larch %s' % (com, time.ctime())]
    for s in header:
        buff.append('%s %s' % (com, s))
    buff.append('%s---------------------------------'% com)
    if label is None:
        label = '  '.join(['col%i' % (i+1) for i in range(len(arrays))])
    buff.append('  %s' % label)

    arrays = numpy.array(arrays)
    for i in range(arraylen):
        w = [' % f' % val[i] for val in arrays]
        buff.append('  '.join(w))

    try:
        fout = open(filename, 'w')
    except:
        _larch.writer.write("cannot open file %s'" % filename)
        return

    try:
        fout.write('\n'.join(buff))
    except:
        _larch.writer.write("cannot write to file %s'" % filename)
        return

    _larch.writer.write("wrote to file '%s'\n" % filename)    

def write_group(filename, group, scalars=None,
                arrays=None, arrays_like=None,
                commentchar='#',  _larch=None):

    items = dir(group)
    npts = 0
    if arrays is None:
        arrays = []
    if scalars is None:
        scalars = []

    if arrays_like is not None and arrays_like in items:
        array = getattr(group, arrays_like)
        if isinstance(array, numpy.ndarray):
            npts = len(array)

    for name in items:
        val = getattr(group, name)
        if isinstance(val, numpy.ndarray):
            if npts != 0 and npts == len(val) and name not in arrays:
                arrays.append(name)

    header =[]
    for s in scalars:
        if s in items:
            val = getattr(group, s)
            header.append("%s = %s" % (s, val))
                          
    label = '  '.join(arrays)

    args = []
    for name in arrays:
        if name in items:
            args.append(getattr(group, name))

    write_ascii(filename, *args, commentchar=commentchar,
                label=label, header=header, _larch=_larch)
        


def registerLarchPlugin():
    return (MODNAME, {'read_ascii': _read_ascii,
                      'write_ascii': write_ascii,
                      'write_group': write_group,
                     })

