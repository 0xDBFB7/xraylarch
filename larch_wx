#!/usr/bin/env python
"""
command-line larch shell with wx-widgets (plotting!) enabled.

"""

import sys
import os
from time import sleep
import threading
import wx

DEBUG = False

if DEBUG:
    import lib as larch
    from lib.plugins import plotter, shellutils
else:
    import larch
    from larch.plugins import plotter, shellutils

PS1 = "larch> "
PS2 = ".....> "

import numpy

PLUGINS = [plotter.registerPlugin, shellutils.registerPlugin]
BANNER = """  Larch %s  M. Newville, T. Trainor (2011)
  using python %s, numpy %s, wx-enabled: version %s
""" %  (larch.__version__,
        '%i.%i.%i' % sys.version_info[:3],
        numpy.__version__, wx.__version__)

def hijack_wx():
    """borrowed from IPython's hijack_wx"""
    def dummyloop(*args, **kw):
        "dummy main loop"
        pass
    orig_wxloop = wx._core_.PyApp_MainLoop
    wx._core_.PyApp_MainLoop = dummyloop
    return orig_wxloop

class LarchShell(object):
    """Basic Larch Execution Shell"""
    def __init__(self, atexit=None):
        self.buff = []
        self.atexit = atexit
        self.in_progress = True
        self.rdline = None
        try:
            import readline
            self.rdline = readline
        except ImportError:
            pass
        self.historyfile = larch.site_config.history_file
        if self.rdline is not None:
            try:
                self.rdline.read_history_file(self.historyfile)
            except IOError:
                pass

        self.larch = larch.Interpreter()
        self.input = larch.InputText(prompt=PS1, interactive=False)
        self.larch.writer = sys.stdout

    def add_wx_components(self, wxparent):
        """add wx enabled symbols to larch -- need a wx parent Window"""
        self.larch.symtable.AddPlugins(PLUGINS,
                                       wxparent=wxparent,
                                       larch=self.larch)
        self.larch.run_init_scripts()
        self.execute()

    def execute(self):
        """run actual larch code (built up and stored in self.input)"""
        if not self.input.input_complete:
            return
        self.in_progress = True
        while len(self.input) > 0:
            block, fname, lineno = self.input.get()
            ret = self.larch.eval(block, fname=fname, lineno=lineno)
            if callable(ret) and not isinstance(ret, type):
                try:
                    if 1 == len(block.split()):
                        ret = ret()
                except:
                    pass
            if self.larch.error:
                err = self.larch.error.pop(0)
                fname, lineno = err.fname, err.lineno
                sys.stdout.write("%s:\n%s\n" % err.get_error())
                for err in self.larch.error:
                    if ((err.fname != fname or err.lineno != lineno) and
                        err.lineno > 0 and lineno > 0):
                        sys.stdout.write("%s\n" % (err.get_error()[1]))
                self.input.clear()
                break
            elif ret is not None:
                sys.stdout.write("%s\n" % repr(ret))
        self.in_progress = False

    def get_input(self):
        """ get input from shell (with raw_input)
        look for exit, quit, Ctrl-D, and also look for help
        and shell commands.

        returns False when ready to exit, otherwise True
        """
        # if there is already input and it is complete,
        # wait for it to be executed by wxtimer thread.
        while self.input.input_complete and len(self.input)>0:
            sleep(0.001)
        # in_progess suggests code is still being executed
        if self.in_progress:
            return True
        # set prompt
        prompt = PS1
        if not self.input.input_complete:
            prompt = PS2
        # get raw input
        try:
            text = raw_input(prompt)
        except EOFError:
            text = 'EOF'

        if text in ('quit', 'exit', 'EOF'):
            if hasattr(self.atexit, '__call__'):
                self.atexit()
                return False
        if text.startswith('help'):
            arg = text[4:]
            if ((arg.startswith('(') and arg.endswith(')')) or
                (arg.startswith("'") and arg.endswith("'")) or
                (arg.startswith('"') and arg.endswith('"'))):
                arg = arg[1:-1]
            text  = "help(%s)"% (repr(arg))
        if text.startswith('!'):
            os.system(text[1:])
        elif len(text) > 0:
            self.input.put(text, lineno=0)
        return True

class WxShellTimer(wx.MiniFrame):
    """hidden wx frame that contains a timer widget.
    This timer widget is what executes Shell code.
    """
    def __init__(self):
        wx.MiniFrame.__init__(self, None, -1, '')
        self.Show(False)
        tid = wx.NewId()
        self.timer = wx.Timer(self, tid)
        wx.EVT_TIMER(self,  tid, self.OnTimer)
        self.shell = None
        self.in_progress = True

    def Start(self):
        """Add wx components to shell, start timer to execute shell code"""
        self.in_progress = True
        self.shell.add_wx_components(self)
        self.timer.Start(50)
        self.in_progress = False

    def OnTimer(self, event=None):
        """timer events -- here we execute any un-executed shell code"""
        if (self.shell.input.input_complete):
            sleep(0.001)
            self.shell.execute()

class WxLarchShell(threading.Thread):
    """wx-enabled Larch Shell"""
    def __init__(self):
        self.shell = LarchShell(atexit=self.atexit)
        class App(wx.App):
            """very basic wxApp, holding a WxShellTimer"""
            def OnInit(self):
                'Create the main window and insert the custom frame'
                self.wxtimer = WxShellTimer()
                self.wxtimer.Show(False)
                return True
        self.app = App(redirect=False)
        self.app.wxtimer.shell = self.shell
        threading.Thread.__init__(self)

    def atexit(self, *args):
        """run at exit of main shell:
        1. write readline history
        2. exit wx mainloop
        """
        shell = self.shell
        if shell.rdline is not None:
            shell.rdline.set_history_length(1000)
            shell.rdline.write_history_file(shell.historyfile)
        if self.app is not None:
            self.app.wxtimer.timer.Stop()
            self.app.ExitMainLoop()

    def run(self):
        """run for main thread: just get input for shell.
        note that wxtimer events cause LarchShell.execute"""
        while self.shell.in_progress:
            sleep(0.001)

        while self.shell.get_input():
            continue

    def mainloop(self):
        """mainloop for WxShell"""
        self.start()
        sys.stdout.write(BANNER)
        sys.stdout.flush()

        self.app.wxtimer.Start()

        self.app.MainLoop()
        self.join()

if __name__ == '__main__':
    ws = WxLarchShell()
    ws.mainloop()
