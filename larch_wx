#!/usr/bin/env python
"""
command-line larch shell with wx-widgets (plotting!) enabled.
"""

import sys
import os
import time
import threading

import wx
import numpy
import lib as larch
from lib.plugins import plotter, shellutils

PLUGINS = [plotter.registerPlugin, shellutils.registerPlugin]
BANNER = """  Larch %s  M. Newville, T. Trainor (2011)
  using python %s, numpy %s, wx-enabled: version %s
""" %  (larch.__version__,
        '%i.%i.%i' % sys.version_info[:3],
        numpy.__version__, wx.__version__)
PS1 = "larch> "
PS2 = ".....> "

def hijack_wx():
    """Modifies wxPython's MainLoop with a dummy so user code does not
    block IPython.  The hijacked mainloop function is returned.
    """
    def dummyloop(*args, **kw):
        pass

    orig_mainloop = None
    if hasattr(wx, '_core_'):
        core = getattr(wx, '_core_')
    elif hasattr(wx, '_core'):
        core = getattr(wx, '_core')
    else:
        raise AttributeError('Could not find wx core module')
    orig_mainloop = core.PyApp_MainLoop
    core.PyApp_MainLoop = dummyloop
    return orig_mainloop

class MiniTimer(wx.MiniFrame):
    def __init__(self, parent):
        self.frame = wx.MiniFrame.__init__(self, parent, -1, ' ')
        self.Show(False)
        self.timerId = wx.NewId()
        self.timer = wx.Timer(self, self.timerId)
        wx.EVT_TIMER(self,  self.timerId, self.OnTimer)

    def Start(self):
        sys.stdout.write(BANNER)
        sys.stdout.flush()
        self.timer.Start(50)

    def Stop(self):
        self.timer.Stop()

    def OnTimer(self, event=None):
        pass

class timerApp(wx.App):
    def OnInit(self):
        'Create the main window and insert the custom frame'
        self.wxtimer = MiniTimer(None)
        self.wxtimer.Show(False)
        return True

    def Start(self):
        self.wxtimer.Start()

    def Stop(self):
        self.wxtimer.Stop()

class LarchShell(threading.Thread):
    def __init__(self, parent=None):
        self.wxapp = timerApp(redirect=False)
        threading.Thread.__init__(self,
                                  name='interpreter thread')
        self.rdline = None
        try:
            import readline
            self.rdline = readline
        except ImportError:
            pass
        homedir = os.environ.get('HOME', os.getcwd())
        self.historyfile = larch.site_config.history_file
        if self.rdline is not None:
            try:
                self.rdline.read_history_file(self.historyfile)
            except IOError:
                pass
        self.prompt = PS1
        self.larch = larch.Interpreter()
        self.input = larch.InputText(prompt=PS1, interactive=False)
        self.larch.writer = sys.stdout

        self.larch.symtable.AddPlugins(PLUGINS,
                                       wxparent=self.wxapp.wxtimer,
                                       larch=self.larch)

        self.larch.run_init_scripts()


    def runcode(self, text):
        text = text.strip()
        if text in ('quit','exit','EOF'):
            n = self.rdline.get_current_history_length()
            if text in ('quit','exit'):
                self.rdline.remove_history_item(n-1)
            return 1

        if text.startswith('help'):
            arg = text[4:]
            if arg.startswith('(') and arg.endswith(')'): arg = arg[1:-1]
            if arg.startswith("'") and arg.endswith("'"): arg = arg[1:-1]
            if arg.startswith('"') and arg.endswith('"'): arg = arg[1:-1]
            text  = "help(%s)"% (repr(arg))
        if text.startswith('!'):
            os.system(text[1:])
        else:
            ret = None
            self.input.put(text,lineno=0)

            self.prompt = PS2
            while len(self.input) > 0:
                block,fname,lineno = self.input.get()
                ret = self.larch.eval(block, fname=fname, lineno=lineno)
                if callable(ret) and not isinstance(ret, type):
                    try:
                        if 1 == len(block.split()):
                            ret = ret()
                    except:
                        pass
                if self.larch.error:
                    err = self.larch.error.pop(0)
                    fname, lineno = err.fname, err.lineno
                    sys.stdout.write("%s:\n%s\n" % err.get_error())
                    for err in self.larch.error:
                        if ((err.fname != fname or err.lineno != lineno) and
                            err.lineno > 0 and lineno > 0):
                            sys.stdout.write("%s\n" % (err.get_error()[1]))
                    self.input.clear()
                    self.prompt = PS1
                    break
                elif ret is not None:
                    sys.stdout.write("%s\n" % repr(ret))
                self.prompt = PS1


    def run(self):
        time.sleep(0.1)
        while True:
            try:
                text = raw_input(self.prompt)
            except EOFError:
                break
            if len(text) > 0:
                self.runcode(text)
        if self.rdline is not None:
            self.rdline.set_history_length(1000)
            self.rdline.write_history_file(self.historyfile)

        self.wxapp.Stop()
        time.sleep(0.05)
        wx.CallAfter(self.wxapp.ExitMainLoop)
        time.sleep(0.05)

    def mainloop(self):
        self.start()
        wxloop = hijack_wx()
        self.wxapp.Start()
        wxloop(self.wxapp)
        self.join()

if __name__ == '__main__':
    LarchShell().mainloop()
